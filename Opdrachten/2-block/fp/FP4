import FPPrac.Trees as T


-- Ex 1

data Tree1a = Leaf1a Int | Node1a Int Tree1a Tree1a
 deriving Show           

tree1a = Node1a 1 (Leaf1a 2)
                 (Node1a 3 (Leaf1a 4)
                           (Leaf1a 5))

pp1a :: Tree1a -> RoseTree
pp1a (Leaf1a n)            = RoseNode (show n) []
pp1a (Node1a n left right) = RoseNode (show n) [pp1a left, pp1a right]


data Tree1b = Leaf1b (Int,Int) | Node1b (Int,Int) Tree1b Tree1b
 deriving Show
tree1b = Node1b (1,1) (Leaf1b (2,2))
                      (Node1b (3,3) (Leaf1b (4,4))
                                    (Leaf1b (5,5)))

pp1b :: Tree1b -> RoseTree
pp1b (Leaf1b n) = RoseNode (show n) []
pp1b (Node1b n left right) = RoseNode (show n) [pp1b left, pp1b right]

data Tree1c = Leaf1c Int | Node1c Tree1c Tree1c

tree1c = Node1c  (Leaf1c 2) (Node1c (Leaf1c 2) (Leaf1c 2))

pp1c :: Tree1c -> RoseTree
pp1c (Leaf1c n) = RoseNode (show n) []
pp1c (Node1c left right) = RoseNode (show "")  [pp1c left, pp1c right]

data Tree1d = Leaf1d (Int,Int) | Node1d [Tree1d] Tree1d Tree1d
 deriving Show

tree1d = Node1d [] (Leaf1d (1,2)) (Node1d [] (Leaf1d (4,5)) (Leaf1d (6,9)))

-- Ex 2

data Tree2a = Leaf2a Int | Node2a Int Tree2a Tree2a
 deriving Show

tree2a = Node2a 1 (Leaf2a 2) (Node2a 3 (Leaf2a 4) (Leaf2a 5))

-- Test
main :: IO ()
main = 
    do
     putStrLn "begin program"
     let tree = Node2a 5 (Leaf2a 3) (Leaf2a 4)
     print tree

     putStrLn "end program"

treeAdd :: Int ->  Tree2a -> Tree2a
treeAdd x (Leaf2a y) = Leaf2a (y+x)
treeAdd x (Node2a y l r) = Node2a (y+x) (treeAdd x l) (treeAdd x r)


treeSquare :: Tree2a -> Tree2a
treeSquare (Leaf2a y) = Leaf2a (y^2)
treeSquare (Node2a y l r) = Node2a (y^2) (treeSquare l) (treeSquare r)

mapTree :: (Int -> Int) -> Tree2a -> Tree2a
mapTree f (Leaf2a y) = Leaf2a (f y)
mapTree f (Node2a y l r) = Node2a (f y) (mapTree f l) (mapTree f r)

addNode :: Tree1b -> Tree1a
addNode (Leaf1b (x,y)) = Leaf1a (x+y)
addNode (Node1b (x,y) l r) = Node1a (x+y) (addNode l)(addNode r)

mapTree2 :: (Int -> Int) -> Tree1b -> Tree1b
mapTree2 f (Leaf1b (x,y)) = Leaf1b ((f x),(f y))
mapTree2 f (Node1b (x,y) l r) = Node1b ((f x), (f y)) (mapTree2 f l) (mapTree2 f r)

-- Ex 3

binMirror :: Tree1a -> Tree1a
binMirror (Leaf1a x) = Leaf1a x
binMirror (Node1a x l r) = Node1a x (binMirror r) (binMirror l)

binMirror2 :: Tree1d -> Tree1d
binMirror2 (Leaf1d (x,y)) = Leaf1d (y,x)
binMirror2 (Node1d x l r) = Node1d x (binMirror2 r) (binMirror2 l)

-- Ex 4

data Tree4  = Leaf4
            | Node4 Int Tree4 Tree4 
 deriving Show

tree4 = Node4 5 (Leaf4) 
                    (Node4 2
                   (Node4 3 (Leaf4) (Leaf4)) 
                   (Node4 9 (Leaf4) (Leaf4)))

insertTree :: Int  -> Tree4 -> Tree4 
insertTree x (Leaf4) = Node4 x Leaf4 Leaf4
insertTree x (Node4 n l r) |x <= n = Node4 n (insertTree x l) r
                           |x > n = Node4 n l (insertTree x r)

makeTree :: [Int] -> Tree4
makeTree [] = Leaf4
makeTree (x:xs) = insertTree x (makeTree xs)

makeList :: Tree4 -> [Int]
makeList Leaf4 = []
makeList (Node4 n l r) = (makeList l)++ [n] ++ (makeList r)

sortList :: [Int] -> [Int]
sortList [] = []
sortList (x:xs) = makeList(makeTree (x:xs))

sortTree :: Tree4 -> Tree4
sortTree (Leaf4) = Leaf4
sortTree (Node4 n l r) = makeTree((makeList (Node4 n l r)))

-- Ex 5

subTreeAt :: Int -> Tree4  -> Tree4
subTreeAt x (Leaf4) = error "Bestaat niet"
subTreeAt x (Node4 n l r)
                          |x == n = Node4 n l r
                          |x < n = (subTreeAt x l)
                          |x > n = (subTreeAt x r)
                          |otherwise = error "Bestaat niet"


-- Ex 6

cutOffAt :: Int -> Tree1a -> Tree1a
cutOffAt _ (Leaf1a n) = Leaf1a n
cutOffAt 0 (Node1a n l r) = Leaf1a n
cutOffAt x (Node1a n l r) = Node1a n (cutOffAt (x-1) l) (cutOffAt (x-1) r)

-- Ex 7

replace :: Int -> [Char] -> Tree1a -> Tree1a
replace x [] (Leaf1a n) = Leaf1a x
replace x [] (Node1a n l r) = (Node1a n l r)
replace x _ (Leaf1a n) = error "Invalid Path"
replace x (z:zs) (Node1a n l r)
                               |z == 'l' = Node1a n (replace x zs l) r
                               |z == 'r' = Node1a n l (replace x zs r)
                               |otherwise = error "Invalid Path"

subTree :: [Char] -> Tree1a -> Tree1a
subTree [] (Leaf1a i) = Leaf1a i
subTree [] (Node1a i a b) = Node1a i a b
subTree _ (Leaf1a n) = error "Path is to long"
subTree (z:zs) (Node1a n l r)
                             |z == 'l' = subTree zs l 
                             |z == 'r' = subTree zs r
                             |otherwise = error "Path is to long"

-- Ex 8

treeB = Node4 5 (Leaf4) (Node4 2 (Leaf4) (Leaf4))

--isBalanced :: Tree4 -> Bool
--isBalanced (Leaf4) = False
--isBalanced (Node4 n l r) = 

isBalanced :: Tree4 -> Bool
isBalanced t = (max - min) < 2
    where  xs  = pathLengths t 0
           max = maximum xs 
           min = minimum xs

pathLengths :: Tree4 -> Int -> [Int]
pathLengths Leaf4 n = [n]
pathLengths (Node4 _ l r) n = (pathLengths l (n + 1)) ++ (pathLengths r (n + 1)) 

fsthalf :: [Int] -> [Int]
fsthalf xs = take ((length xs) `div` 2) xs
sndhalf :: [Int] -> [Int]
sndhalf xs = drop ((length xs) `div` 2) xs


balance = buildBalancedTree . makeList 


buildBalancedTree :: [Int] -> Tree4
buildBalancedTree []    = Leaf4
ibuildBalancedTree xs    = Node4 (head (sndhalf xs)) (buildBalancedTree (fsthalf xs)) (buildBalancedTree (tail (sndhalf xs)))

